use std::fmt::Debug;
use std::marker::PhantomData;

use halo2_proofs::{
    arithmetic::{Field as Halo2Field, FieldExt},
    circuit::{AssignedCell, Chip, Layouter, Region, SimpleFloorPlanner, Value},
    halo2curves::{
        bn256::{Fq, Fr},
        group::ff::PrimeField,
    },
    plonk::{Advice, Circuit, Column, ConstraintSystem, Error, Expression, Fixed, Instance, Selector},
    poly::Rotation,
};
use halo2_proofs::dev::{FailureLocation, MockProver, VerifyFailure};
use rand::SeedableRng;
use rand_xorshift::XorShiftRng;
use sha3::{Digest, Keccak256};

pub trait Field: FieldExt + Halo2Field + PrimeField<Repr=[u8; 32]> {}

// Impl custom `Field` trait for BN256 Fr to be used and consistent with the
// rest of the workspace.
impl Field for Fr {}

// Impl custom `Field` trait for BN256 Frq to be used and consistent with the
// rest of the workspace.
impl Field for Fq {}

#[allow(dead_code)]
/// An assigned cell in the circuit.
#[derive(Clone, Debug)]
pub struct Variable<T, F: Field> {
    assig_cell: AssignedCell<F, F>,
    value: Value<T>,
}

impl<T, F: Field> Variable<T, F> {
    pub(crate) fn new(assig_cell: AssignedCell<F, F>, value: Value<T>) -> Self {
        Self { assig_cell, value }
    }
}

pub struct Word<F: Field>([Variable<u8, F>; 32]);

// ANCHOR: chip-config
/// Chip state is stored in a config struct. This is generated by the chip
/// during configuration, and then stored inside the chip.
/// 需要为芯片配置好实现我们想要的功能所需要的那些列、置换、门。
/// 芯片的状态被存储在一个 config 结构体中，它是在配置过程中由芯片生成，
/// 并且存储在芯片内部。
#[derive(Clone, Debug)]
struct WordConfig<F: Field> {
    /// Randomness used to compress the word encoding.
    r: F,
    /// Selector to toggle the word encoding gate.
    // TODO: This may be replaced by a synthetic selector.
    q_encode: Selector,
    /// Advice columns used to witness the byte representation of the word.
    bytes: [Column<Advice>; 32],
    /// Fixed column containing all possible 8-bit values. This is used in
    /// a lookup argument to range-constrain each byte.
    byte_lookup: Column<Fixed>,
    /// Expression representing `encode(word)`.
    encode_word_expr: Expression<F>,
}

impl<F: Field> WordConfig<F> {
    /// Sets up the configuration of the config by creating the required columns
    /// & selectors and defining the constraints that take part when using a
    /// Word.
    pub fn configure(
        meta: &mut ConstraintSystem<F>,
        r: F,
        q_encode: Selector,
        bytes: [Column<Advice>; 32],
        byte_lookup: Column<Fixed>,
    ) -> Self {
        // Expression representing `encode(word)`.
        let mut encode_word_expr = Expression::Constant(F::zero());

        // Lookup each byte in the witnessed word representation to
        // range-constrain it to 8 bits.
        //
        // TODO: Understand why the `for` loop cannot be moved into
        // the meta.lookup_any() call.
        for byte in bytes.iter().rev() {
            meta.lookup_any("Word byte for range", |meta| {
                let q_encode = meta.query_selector(q_encode);
                let r = Expression::Constant(r);
                let byte = meta.query_advice(*byte, Rotation::cur());
                let byte_lookup = meta.query_fixed(byte_lookup, Rotation::cur());

                // Update encode_word_expr.
                encode_word_expr = encode_word_expr.clone() * r + byte.clone();

                vec![(q_encode * byte, byte_lookup)]
            });
        }

        Self {
            r,
            q_encode,
            bytes,
            byte_lookup,
            encode_word_expr,
        }
    }
}

// ANCHOR: instructions-impl
/// A variable representing a number.
/// 用于表示数的变量
#[derive(Clone)]
struct Number<F: Field>(AssignedCell<F, F>);

// ANCHOR: circuit
/// The full circuit implementation.
///
/// In this struct we store the private input variables. We use `Option<F>` because
/// they won't have any value during key generation. During proving, if any of these
/// were `None` we would get an error.
///
/// 完整的电路实现
///
/// 在这个结构体中，我们保存隐私输入变量。我们使用 `Option<F>` 类型是因为，
/// 在生成密钥阶段，他们不需要有任何的值。在证明阶段中，如果它们任一为 `None` 的话，
/// 我们将得到一个错误。
#[derive(Default)]
struct MyCircuit<F: Field> {
    word: [Value<u8>; 32],
    _marker: PhantomData<F>,
}

impl<F: Field> Circuit<F> for MyCircuit<F> {
    // Since we are using a single chip for everything, we can just reuse its config.
    // 因为我们在任一地方值用了一个芯片，所以我们可以重用它的配置。
    // type Config = FieldConfig;
    // type FloorPlanner = SimpleFloorPlanner;

    // Introduce an additional instance column here to test lookups
    // with public inputs. This is analogous to the bus mapping
    // commitment which will be provided as public inputs.
    type Config = (WordConfig<F>, Column<Instance>);
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
        let r = r();

        let q_encode = meta.complex_selector();

        let bytes: [Column<Advice>; 32] = (0..32)
            .map(|_| meta.advice_column())
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
        let byte_lookup = meta.fixed_column();

        let config = WordConfig::configure(meta, r, q_encode, bytes, byte_lookup);

        let pub_inputs = meta.instance_column();

        // Make sure each encoded word has been committed to in the
        // public inputs.
        meta.lookup_any("Encoded word / Pub inputs", |meta| {
            let q_encode = meta.query_selector(q_encode);
            let pub_inputs = meta.query_instance(pub_inputs, Rotation::cur());

            let encode_word = config.clone().encode_word_expr;

            vec![(q_encode * encode_word, pub_inputs)]
        });

        (config, pub_inputs)
    }
    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        // 加载 look_up 一列数据（0-256行）
        layouter.assign_region(
            || "8-bit table",
            |mut meta| {
                for byte in 0..=u8::MAX {
                    meta.assign_fixed(
                        || format!("load {}", byte),
                        config.0.byte_lookup,
                        byte.into(),
                        || Value::known(F::from(byte as u64)),
                    )?;
                }
                Ok(())
            },
        )?;

        layouter.assign_region(
            || "assign word",
            |mut region| {
                let mut bytes: Vec<Variable<u8, F>> = Vec::with_capacity(32);

                for (idx, (byte, column)) in self.word.iter().zip(config.0.bytes.iter()).enumerate() {
                    // TODO: We will likely enable this selector outside of the helper.
                    config.0.q_encode.enable(&mut region, 0)?;

                    let byte_field_elem = byte.map(|byte| F::from(byte as u64));
                    let cell = region.assign_advice(
                        || format!("assign byte {}", idx),
                        *column,
                        0,
                        || byte_field_elem,
                    )?;

                    bytes.push(Variable::new(cell, *byte));
                }

                Ok(Word(bytes.try_into().unwrap()))
            },
        )?;

        Ok(())
    }
}
// ANCHOR_END: circuit

/// Returns encoding of big-endian representation of a 256-bit word.
pub fn encode<F: Field>(vals: impl Iterator<Item=u8>, r: F) -> F {
    vals.fold(F::zero(), |acc, val| {
        let byte = F::from(val as u64);
        acc * r + byte
    })
}

// TODO: Move into crate-level `constants` file.
/// r = hash([0, 1, ..., 255])
pub fn r<F: Field>() -> F {
    F::from_u128(22)
    // let mut hasher = Keccak256::new();
    // for byte in 0..=u8::MAX {
    //     hasher.process(&[byte]);
    // }
    // let mut r = [0; 64];
    // r[..32].copy_from_slice(hasher.fixed_result().as_slice());
    // F::from_bytes_wide(&r)
}

pub(crate) fn main2() {
    m();
}

fn m() {
    let rng = XorShiftRng::from_seed([
        0x59, 0x62, 0xbe, 0x5d, 0x76, 0x3d, 0x31, 0x8d, 0x17, 0xdb, 0x37, 0x32, 0x54, 0x06,
        0xbc, 0xe5,
    ]);
    let word = Fr::random(rng);
    let circuit = MyCircuit::<Fr> {
        word: word
            .to_repr()
            .iter()
            .map(|b| Value::known(*b))
            .collect::<Vec<_>>()
            .try_into()
            .unwrap(),
        _marker: PhantomData,
    };

    // Test without public inputs
    let prover = MockProver::<Fr>::run(9, &circuit, vec![vec![]]).unwrap();
    assert_eq!(
        prover.verify(),
        Err(vec![VerifyFailure::Lookup {
            name: "Encoded word / Pub inputs",
            lookup_index: 32,
            location: FailureLocation::InRegion {
                region: halo2_proofs::dev::metadata::Region::from((
                    1,
                    "assign word".to_string()
                )),
                offset: 0,
            },
        }])
    );

    // Calculate word commitment and use it as public input.
    let encoded: Fr = encode(word.to_repr().iter().rev().cloned(), r());
    let prover = MockProver::<Fr>::run(9, &circuit, vec![vec![encoded]]).unwrap();
    println!("{:?}", prover);
    assert_eq!(prover.verify(), Ok(()))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn prover() {
        m();
    }
}

