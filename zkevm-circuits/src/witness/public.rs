// Copyright (C) SAFIT. All rights reserved.
// Copyright (C) BABEC. All rights reserved.
// Copyright (C) THL A29 Limited, a Tencent company. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

use crate::constant::{
    BLOCK_IDX_LEFT_SHIFT_NUM, POSEIDON_HASH_BYTES_IN_FIELD, POSEIDON_PUBLIC_LOOKUP_NUM,
    PUBLIC_NUM_ALL_VALUE, PUBLIC_NUM_BEGINNING_PADDING_ROW,
};
use crate::poseidon_circuit::HASH_BLOCK_STEP_SIZE;
use crate::table::PoseidonTable;
use crate::util::{
    convert_u256_to_64_bytes, create_contract_addr_with_prefix, hash_code_poseidon,
    hash_u256_poseidon, SubCircuit,
};
use crate::witness::Witness;
use eth_types::geth_types::{BlockConstants, ChunkData};
use eth_types::{Field, ToBigEndian, U256};
use serde::Serialize;
use std::cmp::Ordering;
use std::collections::{HashMap, HashSet};
use strum_macros::{EnumIter, EnumString};

// Note: some public rows generated by opcode gadgets
#[derive(Clone, Debug, Default, Serialize)]
pub struct Row {
    /// various public information tag, e.g. BlockNumber, TxFrom
    pub tag: Tag,
    /// block_tx_idx generally represents either block_idx or tx_idx.
    /// When representing tx_idx, it equals to block_idx * 2^32 + tx_idx.
    /// Except for tag=BlockHash, means max_block_idx.
    pub block_tx_idx: Option<U256>,
    pub value_0: Option<U256>,
    pub value_1: Option<U256>,
    pub value_2: Option<U256>,
    pub value_3: Option<U256>,
    pub control_length_0: Option<U256>,
    pub control_length_1: Option<U256>,
    pub control_length_2: Option<U256>,

    pub cnt: Option<U256>,
    pub length: Option<U256>,
    /// comments to show in html table that explain the purpose of each cell
    #[serde(skip_serializing)]
    pub comments: HashMap<String, String>,

    pub poseidon_hash: Option<U256>,
}

#[derive(PartialEq, Eq, Clone, Copy, Debug, Default, Serialize, EnumIter, EnumString)]
pub enum Tag {
    #[default]
    Nil,
    ChainId,
    BlockNumber,
    BlockHash,
    // block coinbase and timestamp
    BlockCoinbaseAndTimestamp,
    // block gas limit, and the BaseFee
    BlockGasLimitAndBaseFee,
    // the total number of txs and logs in a block, and the block Prevrandao
    BlockTxLogNumAndPrevrandao,

    // TxIsCreateAndStatus :  include tx is create and call data gas cost, and tx status
    TxIsCreateAndStatus,
    // combine From and Value together to reduce number of lookups
    TxFromValue,
    // combine To and CallDataLength together to reduce number of lookups
    TxToCallDataSize,
    // tx gas limit and tx gas price
    TxGasLimitAndGasPrice,
    TxCalldata,
    TxLog,
    TxLogData,
    // bytecode size
    CodeSize,
    // bytecode hash
    CodeHash,
}

#[derive(Clone, Copy, Debug, Serialize)]
pub enum LogTag {
    /// Tag for log source addr, also indicates 0 topic
    AddrWith0Topic,
    /// Tag for log source addr, also indicates 1 topic
    AddrWith1Topic,
    /// Tag for log source addr, also indicates 2 topic
    AddrWith2Topic,
    /// Tag for log source addr, also indicates 3 topic
    AddrWith3Topic,
    /// Tag for log source addr, also indicates 4 topic
    AddrWith4Topic,
    Topic0,
    Topic1,
    Topic2,
    Topic3,
    // DataSize log data size
    DataSize,
}

impl From<Tag> for usize {
    fn from(t: Tag) -> Self {
        t as usize
    }
}

impl PartialOrd for Tag {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Tag {
    fn cmp(&self, other: &Self) -> Ordering {
        (*self as i32).cmp(&(*other as i32))
    }
}

impl Row {
    /// Get all rows from chunk data except TxStatus and TxLog since they don't exist there
    pub fn from_chunk_data(chunk_data: &ChunkData) -> Result<Vec<Row>, anyhow::Error> {
        let mut result = vec![];
        // store address with bytecode hash to avoid duplicate CodeSize and CodeHash items insert
        let mut bytecode_set = HashSet::new();

        // | ChainId | 0 | chain_id[..16] | chain_id[16..] | 0 | 0 |
        result.push(Row {
            tag: Tag::ChainId,
            // chain_id high 16 byte
            value_0: Some(chunk_data.chain_id.to_be_bytes()[..16].into()),
            // chain_id low 16 byte
            value_1: Some(chunk_data.chain_id.to_be_bytes()[16..].into()),
            comments: [
                ("tag".into(), "ChainId".into()),
                ("value_0".into(), "ChainId[..16]".into()),
                ("value_1".into(), "ChainId[16..]".into()),
            ]
            .into_iter()
            .collect(),
            ..Default::default()
        });

        // the block number of the first block in the chunk
        let block_number_first = chunk_data.blocks[0].eth_block.number.unwrap().as_usize();

        // | BlockNumber | 0 | 0 | Block_Number_first | 0 | Block_Num_in_chunk |
        result.push(Row {
            tag: Tag::BlockNumber,
            value_1: Some(block_number_first.into()),
            value_3: Some(chunk_data.blocks.len().into()),
            comments: [
                ("tag".into(), "BlockNumber".into()),
                ("value_1".into(), "First Block Number".into()),
                ("value_3".into(), "Block Num in chunk".into()),
            ]
            .into_iter()
            .collect(),
            ..Default::default()
        });

        assert_eq!(
            chunk_data.history_hashes.len(),
            chunk_data.blocks.len() + 256
        );

        let mut hash_list = chunk_data.history_hashes.clone();
        if block_number_first % 2 == 0 {
            hash_list.insert(0, 0.into());
        }
        for (i, hash) in hash_list.chunks(2).enumerate() {
            let (first_hash, second_hash) =
                (hash[0], if hash.len() == 1 { 0.into() } else { hash[1] });
            let max_block_idx = 2 * i + 1; // start from 1

            // Skip rows where both hashes are empty.
            // In tests, history_hashes are generally all zeros,
            // which greatly reduces the number of rows in the public table during testing.
            if first_hash.is_zero() && second_hash.is_zero() {
                continue;
            }

            // | BlockHash | max_block_idx | first hash[..16] | first hash[16..] | second hash[..16] | second hash[16..] |
            // max_block_idx indicates the maximum block index within the chunk (including itself) that can read the first hash
            // first hash means the block number is odd, second hash means the block number is even.
            result.push(Row {
                tag: Tag::BlockHash,
                // max_block_idx
                block_tx_idx: Some(max_block_idx.into()),
                // first hash high 16 byte
                value_0: Some(first_hash.to_be_bytes()[..16].into()),
                // first hash low 16 byte
                value_1: Some(first_hash.to_be_bytes()[16..].into()),
                // second hash high 16 byte
                value_2: Some(second_hash.to_be_bytes()[..16].into()),
                // second hash low 16 byte
                value_3: Some(second_hash.to_be_bytes()[16..].into()),
                comments: [
                    ("tag".into(), "BlockHash".into()),
                    ("block_tx_idx".into(), "max_block_idx".into()),
                    ("value_0".into(), "first hash[..16]".into()),
                    ("value_1".into(), "first hash[16..]".into()),
                    ("value_2".into(), "second hash[..16]".into()),
                    ("value_3".into(), "second hash[16..]".into()),
                ]
                .into_iter()
                .collect(),
                ..Default::default()
            });
        }

        // push all 0 row for overflow blockhash
        result.push(Row {
            tag: Tag::BlockHash,
            block_tx_idx: None,
            value_0: None,
            value_1: None,
            value_2: None,
            value_3: None,
            comments: [
                ("tag".into(), "BlockHash".into()),
                ("block_tx_idx".into(), "max_block_idx".into()),
                ("value_0".into(), "first hash[..16]".into()),
                ("value_1".into(), "first hash[16..]".into()),
                ("value_2".into(), "second hash[..16]".into()),
                ("value_3".into(), "second hash[16..]".into()),
            ]
            .into_iter()
            .collect(),
            ..Default::default()
        });

        for (i, block) in chunk_data.blocks.iter().enumerate() {
            let block_constant: BlockConstants = (&block.eth_block).try_into()?;
            // block_idx start from 1
            let block_idx = i + 1;

            // | BlockCoinbaseAndTimestamp | block index | coinbase[..4] | coinbase[4..] | BlockTimestamp[..16] | BlockTimestamp[16..] |
            result.push(Row {
                tag: Tag::BlockCoinbaseAndTimestamp,
                // block index
                block_tx_idx: Some(block_idx.into()),
                // coinbase high 4 byte
                value_0: Some(block_constant.coinbase.as_fixed_bytes()[..4].into()),
                // coinbase low 16 byte
                value_1: Some(block_constant.coinbase.as_fixed_bytes()[4..].into()),
                // timestamp high 16 byte
                value_2: Some(block_constant.timestamp.to_be_bytes()[..16].into()),
                // timestamp low 16 byte
                value_3: Some(block_constant.timestamp.to_be_bytes()[16..].into()),
                comments: [
                    ("tag".into(), "BlockCoinbase".into()),
                    ("block_tx_idx".into(), "block index".into()),
                    ("value_0".into(), "BlockCoinbase[..4]".into()),
                    ("value_1".into(), "BlockCoinbase[4..]".into()),
                    ("value_2".into(), "BlockTimestamp[..16]".into()),
                    ("value_3".into(), "BlockTimestamp[16..]".into()),
                ]
                .into_iter()
                .collect(),
                ..Default::default()
            });

            // | BlockGasLimitAndBaseFee | block index | BlockGasLimit[..16] | BlockGasLimit[16..] | BlockBaseFee[..16] | BlockBaseFee[16..] |
            result.push(Row {
                tag: Tag::BlockGasLimitAndBaseFee,
                // block index
                block_tx_idx: Some(block_idx.into()),
                // gaslimit high 16 byte
                value_0: Some(block_constant.gas_limit.to_be_bytes()[..16].into()),
                // gaslimit low 16 byte
                value_1: Some(block_constant.gas_limit.to_be_bytes()[16..].into()),
                // basefee high 16 byte
                value_2: Some(block_constant.base_fee.to_be_bytes()[..16].into()),
                // basefee low 16 byte
                value_3: Some(block_constant.base_fee.to_be_bytes()[16..].into()),
                comments: [
                    ("tag".into(), "BlockGasLimit".into()),
                    ("block_tx_idx".into(), "block index".into()),
                    ("value_0".into(), "BlockGasLimit[..16]".into()),
                    ("value_1".into(), "BlockGasLimit[16..]".into()),
                    ("value_2".into(), "BlockBaseFee[..16]".into()),
                    ("value_3".into(), "BlockBaseFee[16..]".into()),
                ]
                .into_iter()
                .collect(),
                ..Default::default()
            });

            let log_num: usize = block.logs.iter().map(|log_data| log_data.logs.len()).sum();
            // The total number of txs and logs in a block, and Block prevrandao
            // | BlockTxLogNumAndPrevrandao | block index | tx_num | log_num | BlockPrevrandao[..16] | BlockPrevrandao[16..] |
            result.push(Row {
                tag: Tag::BlockTxLogNumAndPrevrandao,
                // block index
                block_tx_idx: Some(block_idx.into()),
                value_0: Some(block.eth_block.transactions.len().into()),
                value_1: Some(log_num.into()),
                // prevrandao high 16 byte
                value_2: Some(block_constant.difficulty.to_be_bytes()[..16].into()),
                // prevrandao low 16 byte
                value_3: Some(block_constant.difficulty.to_be_bytes()[16..].into()),
                comments: [
                    ("tag".into(), "BlockTxLogNum".into()),
                    ("block_tx_idx".into(), "block index".into()),
                    ("value_0".into(), "tx_num".into()),
                    ("value_1".into(), "log_num".into()),
                    ("value_2".into(), "BlockPrevrandao[..16]".into()),
                    ("value_3".into(), "BlockPrevrandao[16..]".into()),
                ]
                .into_iter()
                .collect(),
                ..Default::default()
            });

            for (tx_idx, tx) in block.eth_block.transactions.iter().enumerate() {
                // due to we decide to start idx at 1 in witness
                let tx_idx = tx_idx + 1;
                let block_tx_idx = (block_idx << BLOCK_IDX_LEFT_SHIFT_NUM) + tx_idx;

                // | TxFromValue | block_tx_idx  | from[..4] | from[4..] | value[..16] | value[16..] |
                result.push(Row {
                    tag: Tag::TxFromValue,
                    block_tx_idx: Some(block_tx_idx.into()),
                    // tx.from high 4 byte
                    value_0: Some(tx.from.as_fixed_bytes()[..4].into()),
                    // tx.from low 16 byte
                    value_1: Some(tx.from.as_fixed_bytes()[4..].into()),
                    // tx.value high 16 byte
                    value_2: Some(tx.value.to_be_bytes()[..16].into()),
                    // tx.value low 16 byte
                    value_3: Some(tx.value.to_be_bytes()[16..].into()),
                    comments: [
                        ("tag".into(), "TxFromValue".into()),
                        (
                            "block_tx_idx".into(),
                            format!("block_tx_idx{}", block_tx_idx),
                        ),
                        ("value_0".into(), "tx.from[..4]".into()),
                        ("value_1".into(), "tx.from[4..]".into()),
                        ("value_2".into(), "tx.value[..16]".into()),
                        ("value_3".into(), "tx.value[16..]".into()),
                    ]
                    .into_iter()
                    .collect(),
                    ..Default::default()
                });

                // to is 0x00ffffffffabcd... if tx is create (0xff... is prefix and first 0x00 is to prevent visiting outside of Fr)
                let (to_hi, to_lo): (U256, U256) = tx.to.map_or_else(
                    || {
                        let to = create_contract_addr_with_prefix(&tx);
                        (to >> 128, to.low_u128().into())
                    },
                    |to| {
                        (
                            to.as_fixed_bytes()[..4].into(),
                            to.as_fixed_bytes()[4..].into(),
                        )
                    },
                );
                // | TxToCallDataSize | block_tx_idx | to_hi | to_lo | 0 | tx.input.len |
                result.push(Row {
                    tag: Tag::TxToCallDataSize,
                    block_tx_idx: Some(block_tx_idx.into()),

                    value_0: Some(to_hi),
                    value_1: Some(to_lo),
                    value_2: Some(0.into()), //len won't > u128
                    // tx.input length
                    value_3: Some(tx.input.len().into()),
                    comments: [
                        ("tag".into(), "TxToCallDataSize".into()),
                        (
                            "block_tx_idx".into(),
                            format!("block_tx_idx={}", block_tx_idx),
                        ),
                        ("value_0".into(), "to_hi".into()),
                        ("value_1".into(), "to_low".into()),
                        ("value_2".into(), "0".into()),
                        ("value_3".into(), "tx.input.len".into()),
                    ]
                    .into_iter()
                    .collect(),
                    ..Default::default()
                });

                // | TxIsCreateAndStatus | block_tx_idx | 1/0(if create contract is 1,else 0) | call data gas cost | call data size | tx status |
                let tx_status = 0.into(); // todo
                let call_data_gas_cost =
                    eth_types::geth_types::Transaction::from(tx).call_data_gas_cost();
                result.push(Row {
                    tag: Tag::TxIsCreateAndStatus,
                    block_tx_idx: Some(block_tx_idx.into()),
                    // if isCreate 1 ,else 0
                    value_0: Some((tx.to.is_none() as u8).into()),
                    value_1: Some(call_data_gas_cost.into()),
                    value_2: Some(tx.input.len().into()),
                    value_3: Some(tx_status),
                    comments: [
                        ("tag".into(), "TxIsCreate".into()),
                        (
                            "block_tx_idx".into(),
                            format!("block_tx_idx{}", block_tx_idx),
                        ),
                        ("value_0".into(), "tx.to.is_none".into()),
                        ("value_1".into(), "call data gas cost".into()),
                        ("value_2".into(), "call data size".into()),
                        ("value_3".into(), "tx status".into()),
                    ]
                    .into_iter()
                    .collect(),
                    ..Default::default()
                });

                let gas_price = tx.gas_price.unwrap_or(0.into());
                // | TxGasLimitAndGasPrice | block_tx_idx | None | tx.gas | gas_price[..16] | gas_price[16..] |
                result.push(Row {
                    tag: Tag::TxGasLimitAndGasPrice,
                    block_tx_idx: Some(block_tx_idx.into()),
                    value_0: None,
                    // tx gas
                    value_1: Some(tx.gas),
                    // tx gas_price high 16 byte
                    value_2: Some(gas_price.to_be_bytes()[..16].into()),
                    // tx gas_price low 16 byte
                    value_3: Some(gas_price.to_be_bytes()[16..].into()),
                    comments: [
                        ("tag".into(), "TxGasLimit".into()),
                        (
                            "block_tx_idx".into(),
                            format!("block_tx_idx{}", block_tx_idx),
                        ),
                        ("value_0".into(), "None".into()),
                        ("value_1".into(), "tx.gas[24..]".into()),
                        ("value_2".into(), "gas_price[..16]".into()),
                        ("value_3".into(), "gas_price[16..]".into()),
                    ]
                    .into_iter()
                    .collect(),
                    ..Default::default()
                });

                if tx.to.is_some() {
                    for (idx, byte) in tx.input.iter().enumerate() {
                        // | TxCalldata | block_tx_idx | 0 | 0 | idx | byte |
                        result.push(Row {
                            tag: Tag::TxCalldata,
                            // tx index
                            block_tx_idx: Some(block_tx_idx.into()),
                            // input index
                            value_2: Some(idx.into()),
                            // input byte
                            value_3: Some(byte.clone().into()),
                            comments: [
                                ("tag".into(), "TxCalldata".into()),
                                (
                                    "block_tx_idx".into(),
                                    format!("block_tx_idx{}", block_tx_idx),
                                ),
                                ("value_2".into(), "idx".into()),
                                ("value_3".into(), "byte".into()),
                            ]
                            .into_iter()
                            .collect(),
                            ..Default::default()
                        });
                    }
                }
            }

            // log data inserts
            for log_data in &block.logs {
                for log in log_data.logs.iter() {
                    let topic_num = log.topics.len();
                    // topic arrays length <= 4
                    assert!(topic_num <= 4);
                    let tx_idx = log.transaction_index.unwrap_or_default().as_usize() + 1;
                    let block_tx_idx = (block_idx << BLOCK_IDX_LEFT_SHIFT_NUM) + tx_idx;

                    let log_index = log.log_index.unwrap_or_default();
                    // compute log_tag by log.topics.length
                    let log_tag = if topic_num == 0 {
                        LogTag::AddrWith0Topic
                    } else if topic_num == 1 {
                        LogTag::AddrWith1Topic
                    } else if topic_num == 2 {
                        LogTag::AddrWith2Topic
                    } else if topic_num == 3 {
                        LogTag::AddrWith3Topic
                    } else {
                        LogTag::AddrWith4Topic
                    };
                    // log.address is H160, 20 bytes
                    let address = log.address.as_bytes();

                    // | TxLog | block_tx_idx | log_index | log_tag | address[..4] | address[4..] |
                    result.push(Row {
                        tag: Tag::TxLog,
                        block_tx_idx: Some(block_tx_idx.into()),
                        // log_index = log.index
                        value_0: Some(log_index),
                        // log_tag should be LogTag::AddrWith[0/1/2/3/4]Topic
                        value_1: Some(U256::from(log_tag as u64)),
                        // address high 4 byte
                        value_2: Some(address[..4].into()),
                        // address low 16 byte
                        value_3: Some(address[4..].into()),
                        comments: [
                            ("tag".into(), format!("{:?}", Tag::TxLog)),
                            ("block_tx_idx".into(), "block_tx_idx".into()),
                            ("value_0".into(), "logIndex".into()),
                            ("value_1".into(), format!("log_tag = {:?}", log_tag)),
                            ("value_2".into(), "address[..4]".into()),
                            ("value_3".into(), "address[4..]".into()),
                        ]
                        .into_iter()
                        .collect(),
                        ..Default::default()
                    });

                    for i in 0..topic_num {
                        // insert topic
                        let topic_hash = log.topics[i].as_bytes();
                        // | TxLog | block_tx_idx | log_index | topic_log_tag | topic_hash[..16] | topic_hash[16..] |
                        result.push(Self::get_log_topic_row(
                            i as u8,
                            topic_hash,
                            block_tx_idx.into(),
                            log_index,
                            Self::get_log_topic_tag(i as u8),
                        ));
                    }

                    // insert log data size
                    // | TxLog | block_tx_idx  | log_index | log_tag=DataSize | 0 | data_len |
                    result.push(Row {
                        tag: Tag::TxLog,
                        block_tx_idx: Some(block_tx_idx.into()),
                        value_0: Some(log_index),
                        value_1: Some((LogTag::DataSize as u64).into()),
                        value_2: Some(0.into()),
                        // log data's length
                        value_3: Some(log.data.len().into()),
                        comments: [
                            ("tag".into(), format!("{:?}", Tag::TxLog)),
                            ("block_tx_idx".into(), "block_tx_idx".into()),
                            ("value_0".into(), "log_index".into()),
                            ("value_1".into(), format!("log_tag = {}", "DataSize")),
                            ("value_2".into(), "0".into()),
                            ("value_3".into(), format!("data_len = {}", log.data.len())),
                        ]
                        .into_iter()
                        .collect(),
                        ..Default::default()
                    });

                    // insert log bytes
                    // | TxLog | block_tx_idx | log_index | 0 | idx | byte |
                    for (data_idx, data) in log.data.iter().enumerate() {
                        result.push(Row {
                            tag: Tag::TxLogData,
                            block_tx_idx: Some(block_tx_idx.into()),
                            value_0: Some(log_index),
                            // data byte index
                            value_2: Some(U256::from(data_idx as u64)),
                            // log data byte
                            value_3: Some(data.clone().into()),
                            comments: [
                                ("tag".into(), format!("{:?}", Tag::TxLogData)),
                                ("block_tx_idx".into(), "block_tx_idx".into()),
                                ("value_0".into(), "idx".into()),
                                ("value_1".into(), "byte".into()),
                                ("value_2".into(), "logIndex".into()),
                            ]
                            .into_iter()
                            .collect(),
                            ..Default::default()
                        });
                    }
                }
            }

            // code size and code hash
            for account in block.accounts.iter() {
                let addr_hi = account.address >> 128;
                let addr_lo = U256::from(account.address.low_u128());
                let code_size = account.code.len();
                let code_hash = hash_code_poseidon(account.code.as_ref());

                if !bytecode_set.contains(&(account.address, code_hash)) {
                    bytecode_set.insert((account.address, code_hash));
                } else {
                    continue;
                }

                // push code size
                // | CodeSize | 0 | addr_hi | addr_lo | code_size hi | code_size lo |
                result.push(Row {
                    tag: Tag::CodeSize,
                    block_tx_idx: Some(0.into()),
                    value_0: Some(addr_hi),
                    value_1: Some(addr_lo),
                    value_2: Some(U256::zero()),
                    value_3: Some(U256::from(code_size)),
                    comments: [
                        ("tag".into(), "CodeSize".into()),
                        ("block_tx_idx".into(), "zero".into()),
                        ("value_0".into(), "address_hi".into()),
                        ("value_1".into(), "address_lo".into()),
                        ("value_2".into(), "code_size hi".into()),
                        ("value_3".into(), "code_size lo".into()),
                    ]
                    .into_iter()
                    .collect(),
                    ..Default::default()
                });

                // push code hash
                // | CodeHash | 0 | addr_hi | addr_lo | Code Hash hi | Code Hash lo |
                result.push(Row {
                    tag: Tag::CodeHash,
                    block_tx_idx: Some(0.into()),
                    value_0: Some(addr_hi),
                    value_1: Some(addr_lo),
                    value_2: Some(code_hash),
                    comments: [
                        ("tag".into(), "CodeHash".into()),
                        ("block_tx_idx".into(), "zero".into()),
                        ("value_0".into(), "address_hi".into()),
                        ("value_1".into(), "address_lo".into()),
                        ("value_2".into(), "code_hash".into()),
                    ]
                    .into_iter()
                    .collect(),
                    ..Default::default()
                });
            }
        }
        Ok(result)
    }

    // get_log_topic_tag return log topic tag
    fn get_log_topic_tag(idx: u8) -> LogTag {
        match idx {
            0 => LogTag::Topic0,
            1 => LogTag::Topic1,
            2 => LogTag::Topic2,
            3 => LogTag::Topic3,
            _ => panic!("illegal log_topic_tag"),
        }
    }

    // get_log_topic_row return topic row
    fn get_log_topic_row(
        topic_idx: u8,
        topic_hash: &[u8],
        block_tx_idx: U256,
        log_index: U256,
        log_tag: LogTag,
    ) -> Row {
        Row {
            tag: Tag::TxLog,
            block_tx_idx: Some(block_tx_idx),
            value_0: Some(log_index),
            // log_tag should be LogTag::Topic0/Topic1/Topic2/Topic3
            value_1: Some(U256::from(log_tag as u64)),
            value_2: Some(topic_hash[..16].into()),
            value_3: Some(topic_hash[16..].into()),
            comments: [
                ("tag".into(), format!("{:?}", Tag::TxLog)),
                ("block_tx_idx".into(), "block_tx_idx".into()),
                ("value_0".into(), "logIndex".into()),
                ("value_1".into(), format!("log_tag = {:?}", log_tag)),
                ("value_2".into(), format!("topicHash[{:}][..16]", topic_idx)),
                ("value_3".into(), format!("topicHash[{:}][16..]", topic_idx)),
            ]
            .into_iter()
            .collect(),
            ..Default::default()
        }
    }
}

pub fn gen_public_poseidon_hash(witness: &mut Witness) -> Vec<[U256; PoseidonTable::INPUT_WIDTH]> {
    // the results are sorted in the order of tags
    witness.public.sort_by(|row1, row2| {
        row1.tag
            .cmp(&row2.tag)
            .then_with(|| row1.block_tx_idx.cmp(&row2.block_tx_idx))
            .then_with(|| row1.value_0.cmp(&row2.value_0))
            .then_with(|| row1.value_1.cmp(&row2.value_1))
            .then_with(|| row1.value_2.cmp(&row2.value_2))
            .then_with(|| row1.value_3.cmp(&row2.value_3))
    });

    let num_padding_begin = PUBLIC_NUM_BEGINNING_PADDING_ROW;
    // 表示输入的长度
    let start_length = (witness.public.len() - num_padding_begin) * PUBLIC_NUM_ALL_VALUE;
    // start_length * POSEIDON_HASH_BYTES_IN_FIELD 对应函数`hash_msg`的cap参数
    let control_series: Vec<U256> = std::iter::successors(
        Some(U256::from(start_length * POSEIDON_HASH_BYTES_IN_FIELD)),
        |n| {
            if *n > U256::from(HASH_BLOCK_STEP_SIZE) {
                Some(U256::from(*n - HASH_BLOCK_STEP_SIZE))
            } else {
                None
            }
        },
    )
    .take(start_length)
    .collect();

    let mut inputs = vec![];

    for row_cur in witness.public.iter_mut().skip(num_padding_begin) {
        inputs.push(U256::from(row_cur.tag as usize));
        inputs.push(row_cur.block_tx_idx.unwrap_or_default());
        inputs.push(row_cur.value_0.unwrap_or_default());
        inputs.push(row_cur.value_1.unwrap_or_default());
        inputs.push(row_cur.value_2.unwrap_or_default());
        inputs.push(row_cur.value_3.unwrap_or_default());
    }
    let poseidon_hash = hash_u256_poseidon(&inputs);

    let mut i = 0;
    let mut cnt = U256::one();
    let length = witness.public.len() - num_padding_begin;
    for row_cur in witness.public.iter_mut().skip(num_padding_begin) {
        row_cur.cnt = Some(cnt.clone());
        row_cur.length = Some(length.into());
        row_cur.poseidon_hash = Some(poseidon_hash.clone());
        row_cur.control_length_0 = Some(control_series[POSEIDON_PUBLIC_LOOKUP_NUM * i + 0]);
        row_cur.control_length_1 = Some(control_series[POSEIDON_PUBLIC_LOOKUP_NUM * i + 1]);
        row_cur.control_length_2 = Some(control_series[POSEIDON_PUBLIC_LOOKUP_NUM * i + 2]);
        i += 1;
        cnt += U256::one();
    }

    inputs
        .chunks(PoseidonTable::INPUT_WIDTH)
        .filter_map(|chunk| {
            if chunk.len() == PoseidonTable::INPUT_WIDTH {
                Some([chunk[0], chunk[1]])
            } else {
                None
            }
        })
        .collect()
}

/// Get instance from witness.public (`&[Row]`), return a vector of vector of F
pub fn public_rows_to_instance<F: Field>(rows: &[Row]) -> Vec<Vec<F>> {
    // collect keccak inputs
    let public_inputs = public_rows_poseidon_hash_inputs(rows);
    // calc public hash
    let hash = hash_u256_poseidon(&public_inputs);
    vec![vec![F::from_uniform_bytes(&convert_u256_to_64_bytes(
        &hash,
    ))]]
}

pub fn public_rows_poseidon_hash_inputs(rows: &[Row]) -> Vec<U256> {
    let mut inputs = vec![];
    for row_cur in rows.iter().skip(PUBLIC_NUM_BEGINNING_PADDING_ROW) {
        inputs.push(U256::from(row_cur.tag as usize));
        inputs.push(row_cur.block_tx_idx.unwrap_or_default());
        inputs.push(row_cur.value_0.unwrap_or_default());
        inputs.push(row_cur.value_1.unwrap_or_default());
        inputs.push(row_cur.value_2.unwrap_or_default());
        inputs.push(row_cur.value_3.unwrap_or_default());
    }
    inputs
}

#[cfg(test)]
mod test {
    use crate::util::chunk_data_test;
    use crate::witness::public::Row;
    use eth_types::call_types::GethCallTrace;
    use eth_types::{Bytes, GethExecTrace, ReceiptLog, H160, H256, U256, U64};
    use ethers_core::types::Log;
    use std::str::FromStr;

    #[test]
    fn from_geth_data() {
        // mock receiptLog
        let log = ReceiptLog{
            logs:             vec![Log {
                address: H160::from_str("0xe7f1725e7734ce288f8367e1bb143e90bb3f0512").unwrap(),
                topics: vec![H256::from_str(
                    "0xbf2ed60bd5b5965d685680c01195c9514e4382e28e3a5a2d2d5244bf59411b93"
                )
                .unwrap(),],
                data: Bytes::from_str("0x000000000000000000000000000000000000000000000000000000003b9aca0000000000000000000000000000000000000000000000000000000000674041ba").unwrap(),
                block_hash: Some(H256::from_str("0xee573172d327d8c99739cd936344bb5567be6e794c6c1863ae97520af81803fe").unwrap()),
                block_number: Some(U64::from(4)),
                transaction_hash: Some(H256::from_str("0x15bc89db9525912ddb289c647ec4b473dc3b326eec95308d4dcb2d8a98de1b99").unwrap()),
                transaction_index: Some(U64::from(0)),
                log_index: Some(U256::from(0)),
                transaction_log_index: None,
                log_type: None,
                removed: Some(false)
            }]
        };
        // mock ChunkData
        let chunk_data = chunk_data_test(
            GethExecTrace {
                gas: 26809,
                failed: false,
                return_value: "".to_owned(),
                struct_logs: vec![],
                call_trace: GethCallTrace::default(),
            },
            &[12, 34, 56, 78],
            &[99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99],
            false,
            log,
        );
        // get all public rows using ChunkData
        let rows = Row::from_chunk_data(&chunk_data);
        // new csv writer
        let mut wtr = csv::Writer::from_writer(vec![]);
        // serialize row
        for row in &rows {
            wtr.serialize(row).unwrap();
        }
        // output in console
        let data = String::from_utf8(wtr.into_inner().unwrap()).unwrap();
        println!("{}", data);
    }
}
